// E816_COM_CONSOLE_SAMPLE.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "conio.h" // for getch()
#include "SafeArray.h"

#define SINGLE_AXIS 1

#import "E816_COM.tlb" no_namespace named_guids

int _tmain(int argc, _TCHAR* argv[])
{
	CoInitialize(0); // this must be called before you can do anything with COM in your thread
	
	{
		IE816Ptr pE816; // this is the smart pointer generated by the #import statement
		                // for easy access to the Interface IE816

		HRESULT hres = pE816.CreateInstance(CLSID_E816); // create one instance
		
		if (SUCCEEDED(hres))
		{
			// try to open communication
			_bstr_t key("E816_COM_SAMPLE");
			BSTR BSKey = (wchar_t*)key; // another conversion of _bstr_t
			long suc = pE816->InterfaceSetupDlg(&BSKey);

			//long port = 1;
			//long baud = 115200;
			//long suc = pE816->ConnectRS232(port, baud);
		
			if (suc == 1)
			{
				
				//printf("\n\nE-816 on COM%d, %d Baud\n", port, baud);

				BSTR StrIDN;
				suc = pE816->qIDN(&StrIDN);
				
				if (suc == 1)
				{
					// The easiest handling of BSTRs is with the compiler COM support
					// class _bstr_t.
					// To access the data in the returned BSTR we use this class that has
					// conversion and assignment operators for most string data types.
					_bstr_t sIDN(StrIDN);
					printf("ID of E816 = \"%s\"\n\n", (char*)sIDN);
				}
				else
					printf("qIDN() failed!\n");


				// We need a SAFEARRAY structure as parameter
				// - the CSafeArray class provided with this example can be helpful
				// to deal with SAFEARRAYs
				double spa[10];
				_bstr_t spabs("AAAAAAAAAA");
				BSTR BSspa = (wchar_t*)spabs; // another conversion of _bstr_t
				long spacmd[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
				CLSafeArray cmd(spacmd, 10);
				CDSafeArray array(10);
				BOOL bFirst = TRUE;
				printf("SPA TEST ");
				if (pE816->qSPA(&BSspa, cmd, array) != 1)
				{
					printf("qSPA() failed!\n");
				}
				else
				{
					array.CopyData(spa, 10);
					printf("SPA for A:");
					for (int i=0; i<10; i++)
						printf(" %d:%f", i+1, spa[i]);
					printf("\n");

					}

				printf("\nMOV-qPOS Test ");

#ifdef SINGLE_AXIS
				_bstr_t bs("A");
#else
				_bstr_t bs("ABDE");
#endif
				BSTR BS = (wchar_t*)bs; // another conversion of _bstr_t
				long svo[4] = {1, 1, 1, 1};
				CLSafeArray svoarray(svo,4);
				
				long suc = pE816->SVO(&BS, svoarray);
				
				if ( suc == 1 )
				{
#ifdef SINGLE_AXIS
					printf("\"SVO A%d\"\n", svo[0]);
#else
					printf("\"SVO A%d B%d D%d E%d\"\n", svo[0], svo[1], svo[2], svo[3]);
#endif
				}
				else
					printf("SVO() failed!\n");

				// Test MOV - qPOS several times
				for (int i=0; i<10; i++)
				{
					if (!(i%10)) printf(".");

					double val[4];
					val[0] = (i%2) ? 1.0 : 10.0;
					val[1] = (i%2) ? 10.0 : 1.0;
					val[2] = (i%2) ? 1.0 : 10.0;
					val[3] = (i%2) ? 10.0 : 1.0;
					CDSafeArray array(val,4);
					
					long suc = pE816->MOV(&BS, array);
					
					if ( suc == 1 )
					{
#ifdef SINGLE_AXIS
						printf("\"MOV A%f\"\n", val[0]);
#else
						printf("\"MOV A%f B%f D%f E%f\"\n", val[0], val[1], val[2], val[3]);
#endif
					}
					else
						printf("MOV() failed!\n");

					CDSafeArray posarray(4);
					
					for (int j=0; j<10; j++)
					{
						suc = pE816->qPOS(&BS, posarray);
						if (suc == 1)
						{
							double pos[4];
#ifdef SINGLE_AXIS
							posarray.CopyData(pos, 1);
							printf("Current position of E-816: ");
							printf("A = %8.4f\n", pos[0]);
#else
							posarray.CopyData(pos, 4);
							printf("Current position of E-816: ");
							printf("A = %8.4f   B = %8.4f   D = %8.4f   E = %8.4f\n", pos[0], pos[1], pos[2], pos[3]);
#endif
						}
						else
						{
							printf("qPOS() failed!\n");
							break;
						}
					}
				}
				pE816->CloseConnection();
			}
			else
				printf("Cannot connect to E-816\n"/* on COM%d, %d baud, port, baud*/);
		}
	} // this will call the destrucur of the smart pointer and free the resources
				
	printf("\n<key to exit...>\n");
	getch();

	CoUninitialize(); // free COM resources
	return 0;
}

